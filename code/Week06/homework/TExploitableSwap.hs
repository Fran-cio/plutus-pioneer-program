{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Control.Monad        (mapM, unless)
import           Plutus.Model         (Run,
                                       TypedValidator (TypedValidator),
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx, userSpend, payToScript, DatumMode (HashDatum), spendScript, payToKey, newUser, ada, Ada (Lovelace), spend, submitTx, utxoAt, valueAt, noErrors, sendBlock, sendValue)
import           PlutusTx.Prelude     (($), Integer, Bool, trace, (++), head)
import           Prelude              (IO, (.), (<>), undefined, Monoid (mconcat), Show (show))
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)
import Plutus.V1.Ledger.Api (PubKeyHash, Value, TxOutRef)
import Debug.Trace (traceM)
import Plutus.V2.Ledger.Api (TxOut(txOutValue))

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
       , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

-- Create transaction that spends "usp" to lock "val" in "valScript"
lockingTx :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx pkh price usp val =
  mconcat
    [ userSpend usp
    , payToScript swapScript (HashDatum (OnChain.DatumSwap pkh price)) val
    ]

-- Create transaction that spends "ref" to unlock "val" from the "valScript" validator
consumingTx :: PubKeyHash -> Integer -> PubKeyHash -> TxOutRef -> TxOutRef -> Value -> Value -> Tx
consumingTx pkh price usr ref1 ref2 val1 val2 =
  mconcat
    [ spendScript swapScript ref1 () (OnChain.DatumSwap pkh price)
      , spendScript swapScript ref2 () (OnChain.DatumSwap pkh price)
      , payToKey usr val1
      , payToKey pkh val2
    ]

doubleConsumingTx :: PubKeyHash -> Integer -> PubKeyHash -> TxOutRef -> TxOutRef -> Value -> Value -> Tx
doubleConsumingTx pkh price usr ref1 ref2 val1 val2 =
  mconcat
    [ spendScript swapScript ref1 () (OnChain.DatumSwap pkh price)
      , spendScript swapScript ref2 () (OnChain.DatumSwap pkh price)
      , payToKey usr val1
      , payToKey usr val1
      , payToKey pkh val2
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run Bool
normalSpending =do   -- SETUP USERS
  u1 <- newUser $ adaValue 1000 <> fakeValue scToken 1
  u2 <- newUser $ adaValue 1000
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  traceM $ "Init User 1 val: " ++ show v1
  traceM $ "Init User 2 val: " ++ show v2
  -- USER 1 LOCKS 100 Lovelaces ("val") IN VALIDATOR
  let price = 100
  let val = fakeValue scToken 1                    -- Define value to be transfered
  sp <- spend u1 val                        -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx u1 price sp val          -- User 1 submits "lockingTx" transaction
  let val = adaValue price                    -- Define value to be transfered
  sp <- spend u2 val                        -- Get user's UTXO that we should spend
  submitTx u2 $ lockingTx u1 price sp val          -- User 1 submits "lockingTx" transaction
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script
  traceM $ "utxos: " ++ show utxos
  let [(ref1, out1),(ref2, out2)] = utxos                  -- We know there is only one UTXO (the one we created before)
      tx = consumingTx u1 price u2 ref1 ref2 (txOutValue out1) (txOutValue out2)  -- Build Tx
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  traceM $ "Mid User 1 val: " ++ show v1
  traceM $ "Mid User 2 val: " ++ show v2
  submitTx u2 tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  traceM $ "Final User 1 val: " ++ show v1
  traceM $ "Final User 2 val: " ++ show v2

  noErrors



doubleSpending :: Run Bool
doubleSpending = do   -- SETUP USERS
  u1 <- newUser $ adaValue 1000 <> fakeValue scToken 2
  u2 <- newUser $ adaValue 1000
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  traceM $ "Init User 1 val: " ++ show v1
  traceM $ "Init User 2 val: " ++ show v2
  -- USER 1 LOCKS 100 Lovelaces ("val") IN VALIDATOR
  let price = 100
  let val = fakeValue scToken 2                    -- Define value to be transfered
  sp <- spend u1 val                        -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx u1 price sp val          -- User 1 submits "lockingTx" transaction
  let val = adaValue price                    -- Define value to be transfered
  sp <- spend u2 val                        -- Get user's UTXO that we should spend
  submitTx u2 $ lockingTx u1 price sp val          -- User 1 submits "lockingTx" transaction
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script
  traceM $ "utxos: " ++ show utxos
  let [(ref2, out2),(ref1, out1)] = utxos                  -- We know there is only one UTXO (the one we created before)
      tx = consumingTx u1 price u2 ref1 ref2 (txOutValue out1) (txOutValue out2)  -- Build Tx
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  traceM $ "Mid User 1 val: " ++ show v1
  traceM $ "Mid User 2 val: " ++ show v2
  submitTx u2 tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  traceM $ "Final User 1 val: " ++ show v1
  traceM $ "Final User 2 val: " ++ show v2

  noErrors
